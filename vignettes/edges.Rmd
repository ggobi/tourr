---
title: "Edges in scatterplot displays"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{edges}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tourr)
library(tidyverse)
library(tsibble)
```

Showing connections between points can be useful in different applications, including geometric shapes, indicating patterns in sequential series or showing connections suggested by a model (for example in clustering). These edges can be added in the 2D scatterplot display (`display_xy`) through the `edges` argument, and should be specified as a two column integer matrix of the indices of ends of lines.

For example, we can generate cube vertices and edges using the `geozoo` package. The information stored as `points` constitutes the input data, and `edges` can directly be passed into the display.

```{r}
# generate 3D cube vertices
cube <- geozoo::cube.iterate(3)
# data is stored points, edges contains the needed two column matrix for connecting points
cube$points
cube$edges
# call grand tour with the scatterplot (xy) display, turning off axes
animate_xy(cube$points, edges = cube$edges, axes = "off")
```

We can use the same functions for higher dimensional cubes as well (but would not print the data).

```{r}
cube5 <- geozoo::cube.iterate(5)
animate_xy(cube5$points, edges = cube5$edges, axes = "off")
```

Using the edges we can connect sequential points, for example in multivariate time series data. As an example here we pick one month of data from the Melbourne pedestrian data available in the `tsibble` package. Since the data points are ordered, we simply generate an edges matrix that connects each row to the following one. The tour showing all edges is quite messy, but clearely shows how outlying points are sequential in time.

```{r}
pedestrian_wide <- pedestrian %>%
  mutate(yearmonth = yearmonth(pedestrian$Date_Time)) %>%
  dplyr::filter(yearmonth == yearmonth("2016 Feb")) %>%
  select(Sensor, Date_Time, Count) %>%
  pivot_wider(id_cols = Date_Time, names_from = Sensor,
              values_from = Count, values_fill = 0) %>%
  as_tibble() %>%
  select(- Date_Time)

pedestrian_edges <- matrix(c(1:(nrow(pedestrian_wide)-1),
                             2:nrow(pedestrian_wide)),
                           ncol = 2)

animate_xy(pedestrian_wide, edges = pedestrian_edges, axes = "off")


```

